---
title: "Mooses Movement"
output: html_document
date: "2025-03-23"
---

# Pakete laden

```{r}
library(here)
library(readr)
library(skimr)
library(dplyr)
library(tidyverse)
library(sf)
library(amt)
library(terra)
library(dplyr)
library(leaflet)
library(mapview)
library(webshot)
library(patchwork)
```

# Pfad automatisch setzen 

GitHub Ordnerstruktur

```{r}
here::here()
```

# Vorbereitung Gruppenarbeit Workflow

## Git Installieren:

Git Programm herunterladen: 
https://git-scm.com/downloads

Notiz: Nach der Installation R neustarten.

Git Projekt beitreten:
Folgendem Git-Ordner beitreten und auf der Website bei GitHub anmelden (Uni-Mail)
Benutzernamen erstellen und an Melanie schicken, damit ihr vollen Zugriff bekommt.

https://github.com/melligld/Mooses

Danach in R "File > New Project > Version Control > Git"

Dort dann den obigen Link einf√ºgen, damit ladet ihr den Git-Ordner herunter. 

================================
üì¶ Git-Workflow f√ºr das R-Projekt
================================
üõ† 1. Git einrichten (nur einmal notwendig)
Gebt euren Namen und eure E-Mail-Adresse an, damit eure Commits zugeordnet werden k√∂nnen:
Im Terminal:
git config --global user.name "Username"
git config --global user.email "MaxMustermann@campus.tu-berlin.de"

=====================================
üöÄ T√§glicher Workflow mit Git in RStudio
=====================================

1Ô∏è‚É£ Vor dem Arbeiten: √Ñnderungen von anderen holen
(Git-Tab in RStudio ‚Üí Klick auf ‚ÄûPull‚Äú)
oder im Terminal: git pull

2Ô∏è‚É£ Dann wie gewohnt arbeiten:
- Skripte oder Dateien √§ndern
- Ergebnisse speichern

3Ô∏è‚É£ √Ñnderungen zum Commit ausw√§hlen:
(Git-Tab ‚Üí H√§kchen bei den ge√§nderten Dateien setzen)

4Ô∏è‚É£ Commit erstellen:
- Im Git-Tab Nachricht schreiben (z.B. ‚ÄûAnalyse erg√§nzt‚Äú)
- Dann auf ‚ÄûCommit‚Äú klicken

5Ô∏è‚É£ √Ñnderungen hochladen:
- Git-Tab ‚Üí ‚ÄûPush‚Äú klicken
oder im Terminal: git push

üí° Tipp: Lieber h√§ufiger kleine Commits machen statt einen gro√üen am Ende!

=====================================
‚úÖ Zusammengefasst:
=====================================
git pull     ‚Üí aktuelle √Ñnderungen holen
git add .    ‚Üí alle √Ñnderungen f√ºr Commit vormerken (meist √ºber Git-Tab gemacht)
git commit -m "Kurze Nachricht" ‚Üí √Ñnderung speichern
git push     ‚Üí √Ñnderungen ins GitHub-Projekt hochladen

=====================================
‚ùóÔ∏èWichtig:
=====================================
‚û§ Immer vor dem Arbeiten zuerst ein `pull` machen.
‚û§ Nur pushen, wenn du committed hast und keine Konflikte offen sind.

# GPS Telemetry Daten (Elche)

## Alle CSVs einlesen und zusammenf√ºgen 

```{r}
# Ordnerpfad zu den CSV-Dateien
data_path <- here("data")
sex_data_path <- here("data", "sex_data", "Peters_Hebblewhite_Alberta-BC_Moose-reference-data.csv")
# Liste aller CSV-Dateien im data-Ordner
csv_files <- list.files(path = data_path, pattern = "\\.csv$", full.names = TRUE)

# Alle CSVs einlesen und zu einem Dataframe zusammenf√ºgen
moose_data <- purrr::map_dfr(csv_files, read_csv, .id = "source_file", show_col_types= FALSE)
colnames(moose_data)[colnames(moose_data) == "tag.local.identifier"] <- "id"

#Geschlechter Zuordnung
sex<- read.csv(sex_data_path)
colnames(sex)[colnames(sex) == "animal.id"] <- "id"

#Moose Datensatz mit Geschlechterzuordnung
moose_data_sex1 <- moose_data %>%
  left_join(sex[, c("id", "animal.sex")], by = "id")

```

## Datensatz "beschneiden"

```{r}
#1. Gruppe A (Datenerhebungszeitraum 2008-2009) in eigenen Datensatz 
moose_A <- moose_data_sex1[moose_data_sex1$id %in% c("1", "3", "5", "10"), ]
unique(moose_A)
#2. zweiten Datensatz erstellen ohne Gruppe A + ohne tote Tiere
moose_B_C<- moose_data_sex1[!moose_data_sex1$id %in% c("1", "3", "5", "10", "31", "9"), ]
#3. in moose_B_C Zeitraum begrenzen um gleichzusetzen
moose_B_C <- moose_B_C[!(moose_B_C$timestamp >= as.POSIXct("2008-12-03 00:00:00") & 
                         moose_B_C$timestamp <= as.POSIXct("2009-03-07 23:59:59")), ]
moose_B_C <- moose_B_C[moose_B_C$timestamp < as.POSIXct("2010-02-18 00:00:00"), ]
summary(moose_B_C$timestamp)
#4. wieder zusammen f√ºhren
moose_comb <- rbind(moose_A, moose_B_C)
dim(moose_comb)
head(moose_comb)


#5. Sex auch "beschneiden" aka 2 tote Tiere rausnehmen
sex<- sex[!sex$id %in% c("31", "9"), ]
```

## Daten√ºberblick

```{r}
glimpse(moose_data)
unique(moose_data$source_file)
skim(moose_data)
```

## 1. Datenbereinigung und Vorbereitung

```{r}
moose_data_sex <- moose_comb %>%
  rename(
    lat = location.lat,
    lon = location.long,
    time = timestamp
  )
moose_data_sex <- moose_data_sex %>%
  filter(!is.na(lat))
moose_data_sex <- moose_data_sex %>%
  filter(!is.na(lon))
```

## Aufnahmezeitraum anschauen

```{r}
# Gesamter Datensatz
moose_data$yearday <- yday(moose_data$timestamp)
moose_data$month   <- month(moose_data$timestamp)
moose_data$hour    <- hour(moose_data$timestamp)
moose_data$kweek   <- week(moose_data$timestamp)
moose_data$date    <- date(moose_data$timestamp)

ggplot(moose_data, aes(date)) +
  geom_bar() +
  theme_bw()

ggsave("Output/moose_complete_timestamp_histogram.png", width = 10, height = 6, dpi = 300)

# Bereinigter Datensatz
moose_data_sex$yearday <- yday(moose_data_sex$time)
moose_data_sex$month   <- month(moose_data_sex$time)
moose_data_sex$hour    <- hour(moose_data_sex$time)
moose_data_sex$kweek   <- week(moose_data_sex$time)
moose_data_sex$date    <- date(moose_data_sex$time)

ggplot(moose_data_sex, aes(date)) +
  geom_bar() +
  theme_bw()

ggsave("Output/moose_adjusted_timestamp_histogram.png", width = 10, height = 6, dpi = 300)
```

## Erste Bewegung visualisieren 

```{r}
library(ggplot2)

ggplot(moose_data_sex %>% filter(id == 1), aes(x = lon, y = lat)) +
  geom_path(color = "darkgreen") +
  labs(title = "Bewegungspfad von Elch 1", x = "Longitude", y = "Latitude") +
  theme_minimal()


ggplot(moose_data_sex, aes(x = lon, y = lat, color = factor(id))) +
  geom_path(alpha = 0.6) +
  labs(title = "Bewegungspfade aller Elche", color = "Elch-ID") +
  theme_minimal()

```

## Untersuchungsgebiet festlegen

Zu einfacheren Bearbeitung der Habitatvariablen legen wir ein UG anhand der GPS-Punkte fest.
```{r}
# Daten in sf-Objekt umwandeln (WGS84-Koordinatensystem)
moose_sf <- st_as_sf(moose_data_sex, coords = c("lon", "lat"), crs = 4326)
moose_proj <- st_transform(moose_sf, crs = 3979)

bbox <- st_bbox(moose_proj)

# In ein Rechteck umwandeln
bbox_poly <- st_as_sfc(bbox)

# Jetzt 50.000 Meter (50 km) puffern
bbox_puffer <- st_buffer(bbox_poly, dist = 50000)
bbox_puffer_wgs <- st_transform(bbox_puffer, crs = 4326)
bbox_sf_proj <- st_transform(bbox_puffer, crs = 3979)

ggplot() +
  geom_sf(data = bbox_sf_proj, fill = NA, color = "red") +
  geom_sf(data = moose_proj, color = "blue", size = 0.5) +
  theme_minimal()
```

# Kernel desity estimation

```{r}
#1. Dataframe mit Koordinaten erstellen
moose_coords <- as.data.frame(st_coordinates(moose_proj))
str(moose_coords)
moose_proj$X <- moose_coords$X
moose_proj$Y <- moose_coords$Y
#remove the spatial (geometry) column-> Converts the sf object into a regular data frame
moose_ng<- st_drop_geometry(moose_proj)
str(moose_ng)

#2. amt Objekt erstellen F√úR EINZELNES TIER
moose1 <- moose_ng[moose_ng$id == "1", ] 
moose1_amt<- make_track(tbl= moose1, #make_track converts non-spatial data into a movement track object
                         .x= X,
                         .y= Y,
                         .t= time,
                         id= id, 
                         crs= 3979)
#3. KDE berechnen F√úR EINZELNES TIER
kde_moose1_95 <- amt::hr_kde(x = moose1_amt, levels = c(0.95))
plot(kde_moose1_95)
hr_area(kde_moose1_95) #82887271

#4. AMT Objekt erstellen f√ºr GESAMT KDE BERECHNUNG
moose_ng <- moose_ng %>%
  filter(!is.na(time))
moose_amt<- make_track(tbl= moose_ng, 
                         .x= X,
                         .y= Y,
                         .t= time,
                         id= id, 
                         crs= 3979)
kde_moose_95 <- amt::hr_kde(x = moose_amt, levels = c(0.95))
plot(kde_moose_95)


#KDE f√ºr jedes Tier einzeln aus "gemeinsamen" amt objekt
#in tibbel umwandeln 
moose_amt_tbl <- as_tibble(moose_amt)
#gesamtergebnisse nach individuen filteren
kde_results <- moose_amt_tbl %>%
  group_by(id) %>%
  nest() %>%
  mutate(kde = map(data, ~ hr_kde(make_track(.x, .x = x_, .y = y_, .t = t_), levels = c(0.95))))  # Convert back to track
print(kde_results)
walk(kde_results$kde, plot)

#f√ºr jedes Tier ausgeben lassen
kde_results <- kde_results %>%
  mutate(area = map(kde, ~ hr_area(.x)$area)) 
print(kde_results)
walk(kde_results$area, print)

#12 kontrolle
kde_moose12 <- kde_results[kde_results$id == "12", ]
kde_moose12 <- kde_results %>% filter(id == "12")
kde_moose12_kde <- kde_moose12$kde[[1]]
kde_area_moose12 <- hr_area(kde_moose12_kde)
```

## Vergleich KDE Weibchen / M√§nnchen

```{r}
#Neuen Datensatz erstellen mit Fl√§chenangaben und Geschlecht f√ºr Visualisierung ect.
#Sex datensatz als basis- alle Spalten mit nur NA entfernen
moose_data_sex_area<- sex %>%
  select(where(~ !all(is.na(.))))
#Area spalte aus kde_results anh√§ngen
moose_data_sex_area <- moose_data_sex_area %>%
  left_join(kde_results %>% select(id, area), by = "id")
#Bearbeitug Datensatz
moose_data_sex_area$area<- as.numeric(unlist(moose_data_sex_area$area))
#Area Angaben in km^2 umrechnen
moose_data_sex_area$area<- moose_data_sex_area$area/1000000

boxplot(area ~ animal.sex, data = moose_data_sex_area, 
        ylim = c(0, 2000),
        main = "Home Range Area by Sex",
        xlab = "Sex",
        ylab = "Area (m¬≤)",
        col= c("lightblue", "pink"))

#Signifikanztest auf Unterschiede zwischen den Geschlechtern
hist(moose_data_sex_area$area)
wilcox.test(as.numeric(moose_data_sex_area$area)~moose_data_sex_area$animal.sex)


#Gesamtfl√§che pro Geschlecht berechnen
total_area_by_sex <- moose_data_sex_area %>%
   group_by(animal.sex) %>%
   summarise(total_area_km2 = sum(area, na.rm = TRUE))
 
#Ausgabe: Tabelle & Klartext
print(total_area_by_sex)
 
 
#Durchschnittliche Home Range Fl√§che pro Geschlecht
mean_area_by_sex <- moose_data_sex_area %>%
   group_by(animal.sex) %>%
   summarise(mean_area_km2 = mean(area, na.rm = TRUE))
 
#Ausgabe
print(mean_area_by_sex)

```

# Plotten der KDEs

```{r}
#Plotten der KDEs
# KDE in sf umwandeln und sex hinzuf√ºgen
kde_results_sex <- kde_results %>%
  left_join(sex %>% select(id, animal.sex), by = "id")
kde_results_sex <- kde_results_sex %>%
  mutate(kde_results = map(kde, ~ hr_isopleths(.x)))
kde_results_sex <- kde_results_sex %>%
  mutate(kde_results = map(kde_results, ~ st_set_crs(.x, 3979)))

# 1. Berechnung Bounding Box f√ºr jeden KDE, zur Skalierung der Darstellung
kde_results_sex <- kde_results_sex %>%
  mutate(bbox = map(kde_results, st_bbox)) %>%
  mutate(x_range = map_dbl(bbox, ~ .x["xmax"] - .x["xmin"]),
         y_range = map_dbl(bbox, ~ .x["ymax"] - .x["ymin"]))
# 2. Bestimme die maximalen Spannweiten 
max_x_range <- max(kde_results_sex$x_range)
max_y_range <- max(kde_results_sex$y_range)

# KDEs mit angepasster Skalierung und Farbgebung plotten
kde_plots <- kde_results_sex %>%
  mutate(plot = pmap(list(kde_results, bbox, id, animal.sex), function(kde, bbox, id, sex) {

    x_center <- (bbox["xmax"] + bbox["xmin"]) / 2
    y_center <- (bbox["ymax"] + bbox["ymin"]) / 2
    
    ggplot() +
      geom_sf(data = kde, aes(fill = sex), alpha = 1) +  # KDE nach Geschlecht f√§rben
      scale_fill_manual(values = c("f" = "lightblue", "m" = "pink")) +  # Farben f√ºr f und m
      ggtitle(paste("ID", id)) +
      xlim(x_center - max_x_range / 2, x_center + max_x_range / 2) +
      ylim(y_center - max_y_range / 2, y_center + max_y_range / 2) +
      theme_minimal() +
      theme(axis.text = element_blank(),
            axis.ticks = element_blank(),
            axis.title = element_blank(),
            legend.position = "none")
  }))

# 4. Plots in Rasteransicht darstellen mit einer einzigen Legende
wrap_plots(kde_plots$plot) + 
  plot_layout(ncol = 6) +
  plot_annotation(title = "KDEs of Individuals", 
                  theme = theme(plot.title = element_text(size = 16, hjust = 0.5)))
```

# Plotten der KDE √úbersicht mit Hintergrundkarte

```{r}
# Transform the CRS to WGS 84
kde_results_sf <- kde_results_sex %>%
  mutate(kde_sf = map2(kde_results, animal.sex, function(kde, sex) {
    kde_sf <- st_as_sf(kde)  # Konvertiert KDE in sf-Objekt
    kde_sf$sex <- sex        # F√ºgt das Geschlecht als Spalte hinzu
    return(kde_sf)
  }))

kde_all_sf <- do.call(rbind, kde_results_sf$kde_sf)
st_crs(kde_all_sf) <- 3979
kde_all_sf_wgs84 <- st_transform(kde_all_sf, crs = 4326)

# Create a leaflet map with satellite imagery
m <- leaflet() %>%
  addProviderTiles("Esri.WorldImagery") %>%  # Add Esri satellite imagery
  setView(lat = 53.5, lng = -119.55, zoom = 7.2)  # Set initial view
# Hinzuf√ºgen der KDEs
pal <- colorFactor(c("lightblue", "pink"), domain = kde_all_sf_wgs84$sex)
m <- m %>%
  addPolygons(
    data = kde_all_sf_wgs84,
    fillColor = ~pal(sex),
    fillOpacity = 0.7,
    color = "black",
    weight = 1,
    label = ~paste("Sex: ", sex)
  )
# Legende Einf√ºgen
m <- m %>%
  addLegend(
    "bottomright",
    colors = c("lightblue", "pink"),
    labels = c("f", "m"),
    title = "Sex",
    opacity = 0.7
  )
# Karte anzeigen lassen
m
```

# Landcover Daten

## Kurzinfo zum Datensatz:

    NALCMS 2010 Land Cover f√ºr Kanada.

    Rasterdaten (GeoTIFF), 30 m Aufl√∂sung.

    Klassifiziert in 19 Landbedeckungstypen (z.B. Nadelwald, Feuchtgebiete, st√§dtisch).

    Projektion: EPSG:3979 (Lambert Conformal Conic).

## Datenimport und erste Rasteranalyse  

Der folgende Code-Chunk ist nicht auszuf√ºhren, da der Datensatz zu gro√ü f√ºr das GitHub ist. Alle weiteren Schritte werden mit dem Zuschnitt auf das Untersuchungsgebiet gemacht, der Zuschnitt wird im n√§chsten Chunk eingeladen.

```{r}
#cand_Landcover_3979 <- rast("C:/Users/Florian/Downloads/landcover-2010-classification.tif")

# √úbersicht
#cand_Landcover_3979
#plot(cand_Landcover_3979)
#levels(cand_Landcover_3979)
#freq(cand_Landcover_3979)

# Zuschneiden auf das Untersuchungsgebiet 

#bbox_sf_proj <- st_transform(bbox_puffer, crs(cand_Landcover_3979))

#cand_Landcover_studyarea_3979 <- crop(cand_Landcover_3979, bbox_sf_proj)
freq(cand_Landcover_studyarea_3979) #vllt noch interessant (H√§ufigkeit der Landnutzungsklassen)
#plot(cand_Landcover_studyarea_3979)

# Speichern der Datei f√ºr weitere Arbeitsschritte 
#writeRaster(cand_Landcover_studyarea_3979, "cand_Landcover_studyarea_3979.tif", filetype = "GTiff", overwrite = TRUE)
```

## Dateiimport GitHub kompatibel

Ab hier k√∂nnen die Rasterdaten als Zuschnitt auf das Untersuchungsgebiet √ºber das GitHub eingeladen werden. 
```{r}
cand_Landcover_studyarea_3979 <- terra::rast(here("data", "cand_Landcover_studyarea_3979.tif"))

# Zuordnung der Gruppen (gem√§√ü Metadaten des Datensatzes)
# F√ºr die Sp√§tere Darstellung im GGplot
landcover_classes <- data.frame(
  code = 1:19,
  class = c(
    "Temperate or sub-polar needleleaf forest",
    "Sub-polar taiga needleleaf forest",
    "Tropical or sub-tropical broadleaf evergreen forest",
    "Tropical or sub-tropical broadleaf deciduous forest",
    "Temperate or sub-polar broadleaf deciduous forest",
    "Mixed forest",
    "Tropical or sub-tropical shrubland",
    "Temperate or sub-polar shrubland",
    "Tropical or sub-tropical grassland",
    "Temperate or sub-polar grassland",
    "Sub-polar or polar shrubland-lichen-moss",
    "Sub-polar or polar grassland-lichen-moss",
    "Sub-polar or polar barren-lichen-moss",
    "Wetland",
    "Cropland",
    "Barren lands",
    "Urban and built-up",
    "Water",
    "Snow and ice"
  )
)


plot(cand_Landcover_studyarea_3979)
```

# DEM Kanda

## Kurzinfo zum Datensatz:

    Canadian Digital Elevation Model (CDEM) ‚Äì Mosaik aus H√∂henrasterdaten von NRCan.

    Aufl√∂sung: Horizontal 10‚Äì100m, vertikale Genauigkeit 8‚Äì43m.

    Koordinatensystem: EPSG:4617 (geografisch), H√∂henbezug EPSG:5713.

    Format: GeoTIFF, verf√ºgbar als vordefiniertes oder benutzerdefiniertes Mosaik.

## Datenimport

Das Natural Resources Canada stellt die DEM kostenlos zur Verf√ºgung, folgenden Video erkl√§rt den Daten-Download:
https://www.youtube.com/watch?v=dfHNghqHdXI&ab_channel=DonBoyes

```{r}
# Indentifizierung der Indexnummern zum Download der richtigen DEM Abschnitte
# Die Zuordnung der Indexnummern ist als shape Datei zu downloaden:
# https://open.canada.ca/data/en/dataset/7f245e4d-76c2-4caa-951a-45d1d2051333

nts_index <- st_read("data/DEM/nts_snrc_1m.shp")
nts_index_proj <- st_transform(nts_index, crs = 3979)

ggplot() +
  geom_sf(data = nts_index_proj, aes(fill = IDENTIF), color = "black", alpha = 0.4, show.legend = FALSE) +
  geom_sf_text(data = nts_index_proj, aes(label = IDENTIF), size = 3) +
  geom_sf(data = bbox_sf_proj, fill = NA, color = "red", linewidth = 1) +
  theme_minimal()

# Eine Stufe feiner zum Download ben√∂tigt

nts_index_2 <- st_read("data/DEM/nts_snrc_250k.shp")
nts_index_proj_2 <- st_transform(nts_index_2, crs = 3979)

# Vorbereitung zum festlegen von xlim und ylim, da Indexnummern im 1. Versuch auf der Karte nicht lesbar

bbox <- st_bbox(bbox_sf_proj)
expand <- 10000  # in Metern (bei Projektionssystem in Meter)

# Optische Identifizierung der DEM Abschnitte (Anschlie√üend: manueller Download im FTP-Verzeichnis)

ggplot() +
  geom_sf(data = nts_index_proj, aes(fill = IDENTIF), color = "black", alpha = 0.4, show.legend = FALSE) +
  geom_sf(data = nts_index_proj_2, aes(fill = NTS_SNRC), color = "black", alpha = 0.4, show.legend = FALSE) +
  geom_sf_text(data = nts_index_proj_2, aes(label = NTS_SNRC), size = 2) +
  geom_sf(data = moose_proj, color = "red", size = 0.4, alpha = 0.6) +
   geom_sf(data = bbox_sf_proj, fill = NA, color = "red", linewidth = 1) +
  coord_sf(
    xlim = c(bbox["xmin"] - expand, bbox["xmax"] + expand),
    ylim = c(bbox["ymin"] - expand, bbox["ymax"] + expand)
  ) +
  theme_minimal()

# Dateipfade aller GeoTIFFs aus dem Verzeichnis holen

#dem_files <- list.files("data/DEM", pattern = "\\.tif$", full.names = TRUE)

# Alle DEMs einlesen und zu einem Mosaik zusammenf√ºgen

#dem_list <- lapply(dem_files, rast)
#dem_mosaic <- do.call(mosaic, dem_list)

#In das richtige CRS projezieren. ACHTUNG! - nicht erneut ausf√ºhren dauert sehr lange!:

#dem_mosaic_3979 <- project(dem_mosaic, cand_Landcover_3979)
#dem_studyarea <- crop(dem_mosaic_3979, bbox_sf_proj)
#writeRaster(dem_studyarea, "data/DEM/dem_studyarea_3979.tif",
#            filetype = "GTiff",
#            wopt = list(gdal = c("COMPRESS=LZW")),
#            overwrite = TRUE)

# Auch die komprimierte Datei ist zu gro√ü f√ºr GitHUB (daher manueller download und einf√ºgen in die Ordnerstruktur)
dem_studyarea_3979 <- terra::rast(here("data", "DEM", "dem_studyarea_3979.tif"))

# Plot zur Kontrolle
plot(dem_studyarea_3979)


```

# Resource selection function

## Vorbereitung des Umweltvariablen-Stacks f√ºr die RSF

```{r}
# Landcover-Raster wird auf die Aufl√∂sung des DEM resampled (nearest neighbor f√ºr kategoriale Daten)

cand_Landcover_aligned <- resample(cand_Landcover_studyarea_3979, dem_studyarea_3979, method = "near")

plot(cand_Landcover_aligned)
# DEM wird standardisiert (z-transformiert) - Auch nicht unbedingt nochmal ausf√ºhren.
# dem_mosaic_scaled <- scale(dem_studyarea_3979)
# Skalierter DEM wird komprimiert als GeoTIFF gespeichert und erneut eingelesen
# writeRaster(dem_mosaic_scaled, "data/DEM/dem_studyarea_scaled.tif",
#          filetype = "GTiff",
#          wopt = list(gdal = c("COMPRESS=LZW")),
#          overwrite = TRUE)

# Datei zu gro√ü f√ºr GitHub, kombrimierte Datei manuell downloaden und in Ordnerstruktur einf√ºgen.

dem_studyarea_scaled <- terra::rast(here("data", "DEM", "dem_studyarea_scaled.tif"))
plot(dem_studyarea_scaled)
# Stack aus beiden Rastern

rsf_stack <- c(cand_Landcover_aligned, dem_studyarea_scaled)
names(rsf_stack) <- c("landcover", "elevation")

# Kontrolle

plot(rsf_stack)

```



## Kontrolle auf Korrelation 

```{r}
library(corrplot)


# Korrelation berechnen
M <- terra::layerCor(rsf_stack, fun = "pearson")

# Plot der Korrelationsmatrix
corrplot(M$correlation, type = "upper", tl.col = "black", tl.srt = 45)
```

-> Korrelation sollte auch f√ºr die einzelnen Landnutzungsklassen zur Elevation getestet werden, daher legen wir einen Dummie-Datzensatz f√ºr die Landnutzungsklassen an und kontrollieren auf Korrelation.

```{r}
# 1. Dummy-Raster f√ºr jede Landnutzungsklasse erzeugen (1 bis 19)
landcover_dummies <- lapply(1:19, function(k) rsf_stack[["landcover"]] == k)

# 2. Benennen der Layer
names(landcover_dummies) <- paste0("lc_", 1:19)

# 3. Als SpatRaster zusammenf√ºhren
landcover_stack <- terra::rast(landcover_dummies)

# 4. Elevation anh√§ngen
lc_env_stack <- c(landcover_stack, rsf_stack[["elevation"]])
names(lc_env_stack)[20] <- "elevation"  # Sauber benennen

# 5. Korrelation berechnen
cor_matrix <- terra::layerCor(lc_env_stack, fun = "pearson")

# 6. Optional: Visualisierung
library(corrplot)
corrplot(cor_matrix$correlation, type = "upper", tl.col = "black", tl.srt = 45)

```

## Vorbereitung zur Erstellung der Random-Points

1. Reduzierung des Datensatz: Die n√§chstgelegende Aufnahme zu 13 Uhr!
2. Vorbereitung der KDE (Home Ranges)
3. Hinzuf√ºgen der Random-Points

```{r}
#Kontrolle wie viele Datenpunkte pro ID enthalten sind
table(moose_amt$id)

#Funktion f√ºr Punkt 1 (Individum bezogen)
get_daily_near13 <- function(df) {
  df %>%
    mutate(date = as.Date(t_),
           diff_13 = abs(lubridate::hour(t_) + lubridate::minute(t_) / 60 - 13)) %>%
    group_by(id, date) %>%
    slice_min(order_by = diff_13, with_ties = FALSE) %>%
    ungroup()
}

# Ausf√ºhrung der Funktion
moose_13 <- get_daily_near13(moose_amt)

# Kontrolle, wie viele Datenpunkte pro Tier geblieben sind
table(moose_13$id)

# Vorbereitung der KDE (Polygone f√ºr Punkterzeugung)
kde_results <- kde_results %>%
  mutate(poly_95 = map(kde, ~ hr_isopleths(.x)))

# Kontrolle ob f√ºr jedes Tier ein Polygon vorhanden ist
kde_results %>%
  mutate(valid_poly = map_lgl(poly_95, ~ !is.null(.x) && nrow(.x) > 0)) %>%
  count(valid_poly)

# Erstellung der Punkte
kde_randompoints <- kde_results %>%
  filter(id %in% moose_13$id) %>%
  transmute(id, random_points = map2(poly_95, id, ~ st_sample(.x, 
    size = sum(moose_13$id == .y) * 20, type = "random")))

# Kontrolle wie viele Punkte es sind
kde_randompoints %>%
  mutate(n_random = map_int(random_points, length)) %>%
  select(id, n_random)

```

## Umweltvariablen f√ºr die Punkte extrahieren

### Ablauftest f√ºr ein Individuum zur Vorbereitung einer Funktion

```{r}

# 1. Geometrie holen und in sf-Objekt umwandeln
rp_sf_1 <- st_as_sf(kde_randompoints$random_points[[1]])

# 2. Koordinaten extrahieren
coords <- st_coordinates(rp_sf_1)

# 3. Track-Objekt erstellen
rp_track_1 <- make_track(
  tbl = tibble(x = coords[,1], y = coords[,2], id = "1"),
  .x = x, .y = y, id = id, crs = 3979
)

# 4. Extraktion
env_rp_1 <- extract_covariates(rp_track_1, rsf_stack)
```


### Funktion zur Extraktion der Habitatvariablen (TRUE und Random Points)

```{r}
env_all_list <- list()

for (i in seq_len(nrow(kde_randompoints))) {
  id <- kde_randompoints$id[i]
  geom <- kde_randompoints$random_points[[i]]
  
  # Random Points zu Koordinaten
  coords <- st_coordinates(geom)
  rp_tbl <- tibble(x = coords[,1], y = coords[,2], id = id)
  rp_track <- make_track(rp_tbl, .x = x, .y = y, id = id, crs = 3979)
  env_rp <- extract_covariates(rp_track, rsf_stack)
  env_rp$case_ <- FALSE
  
  # True Points
  moose_df <- moose_13 %>% filter(id == !!id)
  moose_track <- make_track(moose_df, .x = x_, .y = y_, .t = t_, id = id, crs = 3979)
  env_true <- extract_covariates(moose_track, rsf_stack)
  env_true$case_ <- TRUE
  
  # Kombinieren
  env_all_list[[as.character(id)]] <- bind_rows(env_true, env_rp)
}
```

# Resource selection function

GLMM (binomial, logit-Link) mit:

    festen Effekten: elevation + landcover

    Zufallsinterzept f√ºr id ‚Üí erlaubt individuelle Variation je Elch
    
```{r}
# Vorbereitung der Daten f√ºr das GLMM
rsf_df <- bind_rows(env_all_list)
rsf_df$case_ <- as.integer(rsf_df$case_)  # TRUE/FALSE ‚Üí 1/0

# Anwednung GLMM
library(lme4)
model_glmm <- glmer(case_ ~ elevation + as.factor(landcover) + (1 | id),
                    data = rsf_df,
                    family = binomial)

# Ergebniszusammenfassung
summary(model_glmm)

# Speichern des fertigen GLMM-Objekts
saveRDS(model_glmm, file = here::here("output", "model_glmm.rds"))

# Einlesen bei sp√§terer Nutzung
#model_glmm <- readRDS("results/model_glmm.rds")
```
```{r}

```

# Visualisierung der Ergebnisse

```{r}
# 1. Effekt-Koeffizienten extrahieren
coefs <- summary(model_glmm)$coefficients %>%
  as.data.frame() %>%
  rownames_to_column("term") %>%
  filter(term == "elevation" | grepl("as.factor\\(landcover\\)", term)) %>%
  mutate(
    landcover_code = as.numeric(gsub("as.factor\\(landcover\\)", "", term)),
    class = ifelse(term == "elevation", "Elevation", landcover_classes$class[match(landcover_code, landcover_classes$code)]),
    lower = Estimate - 1.96 * `Std. Error`,
    upper = Estimate + 1.96 * `Std. Error`
  ) %>%
  filter(abs(Estimate) < 10)  # entfernt Extremwerte


# 2. Plot
ggplot(coefs, aes(x = reorder(class, Estimate), y = Estimate)) +
  geom_point(color = "black") +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2, color = "black") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey40") +
  coord_flip() +
  labs(x = "Variable", y = "Effect (log-Odds)",
       title = "RSF-Model: Effects of Elevation and Landcover") +
  theme_minimal() +
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    text = element_text(color = "black")
  )

#ggsave("Output/RSF-Model Values.png", width = 8, height = 6, dpi = 300)
```


