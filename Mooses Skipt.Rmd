---
title: "Mooses Movement"
output: html_document
date: "2025-03-23"
---

# Pakete laden
```{r}
library(here)
library(readr)
library(skimr)
library(dplyr)
library(tidyverse)
library(sf)
library(amt)
library(terra)
```

# Pfad automatisch setzen 

```{r}
here::here()
```

# Git Installieren:

Git Programm herunterladen: 
https://git-scm.com/downloads

Notiz: Nach der Installation R neustarten.

Git Projekt beitreten:
Folgendem Git-Ordner beitreten und auf der Website bei GitHub anmelden (Uni-Mail)
Benutzernamen erstellen und an Melanie schicken, damit ihr vollen Zugriff bekommt.

https://github.com/melligld/Mooses

Danach in R "File > New Project > Version Control > Git"

Dort dann den obigen Link einfÃ¼gen, damit ladet ihr den Git-Ordner herunter. 

================================
ğŸ“¦ Git-Workflow fÃ¼r das R-Projekt
================================
ğŸ›  1. Git einrichten (nur einmal notwendig)
Gebt euren Namen und eure E-Mail-Adresse an, damit eure Commits zugeordnet werden kÃ¶nnen:
Im Terminal:
git config --global user.name "Username"
git config --global user.email "MaxMustermann@campus.tu-berlin.de"

=====================================
ğŸš€ TÃ¤glicher Workflow mit Git in RStudio
=====================================

1ï¸âƒ£ Vor dem Arbeiten: Ã„nderungen von anderen holen
(Git-Tab in RStudio â†’ Klick auf â€Pullâ€œ)
oder im Terminal: git pull

2ï¸âƒ£ Dann wie gewohnt arbeiten:
- Skripte oder Dateien Ã¤ndern
- Ergebnisse speichern

3ï¸âƒ£ Ã„nderungen zum Commit auswÃ¤hlen:
(Git-Tab â†’ HÃ¤kchen bei den geÃ¤nderten Dateien setzen)

4ï¸âƒ£ Commit erstellen:
- Im Git-Tab Nachricht schreiben (z.B. â€Analyse ergÃ¤nztâ€œ)
- Dann auf â€Commitâ€œ klicken

5ï¸âƒ£ Ã„nderungen hochladen:
- Git-Tab â†’ â€Pushâ€œ klicken
oder im Terminal: git push

ğŸ’¡ Tipp: Lieber hÃ¤ufiger kleine Commits machen statt einen groÃŸen am Ende!

=====================================
âœ… Zusammengefasst:
=====================================
git pull     â†’ aktuelle Ã„nderungen holen
git add .    â†’ alle Ã„nderungen fÃ¼r Commit vormerken (meist Ã¼ber Git-Tab gemacht)
git commit -m "Kurze Nachricht" â†’ Ã„nderung speichern
git push     â†’ Ã„nderungen ins GitHub-Projekt hochladen

=====================================
â—ï¸Wichtig:
=====================================
â¤ Immer vor dem Arbeiten zuerst ein `pull` machen.
â¤ Nur pushen, wenn du committed hast und keine Konflikte offen sind.



# Alle CSVs einlesen und zusammenfÃ¼gen 

```{r}
# Ordnerpfad zu den CSV-Dateien
data_path <- here("data")
sex_data_path <- here("data", "sex_data", "Peters_Hebblewhite_Alberta-BC_Moose-reference-data.csv")
# Liste aller CSV-Dateien im data-Ordner
csv_files <- list.files(path = data_path, pattern = "\\.csv$", full.names = TRUE)

# Alle CSVs einlesen und zu einem Dataframe zusammenfÃ¼gen
moose_data <- purrr::map_dfr(csv_files, read_csv, .id = "source_file", show_col_types= FALSE)
colnames(moose_data)[colnames(moose_data) == "tag.local.identifier"] <- "id"

#Geschlechter Zuordnung
sex<- read.csv(sex_data_path)
colnames(sex)[colnames(sex) == "animal.id"] <- "id"

#Moose Datensatz mit Geschlechterzuordnung
moose_data_sex1 <- moose_data %>%
  left_join(sex[, c("id", "animal.sex")], by = "id")

```
##Datensatz "beschneiden"
```{r}
#1. Gruppe A (Datenerhebungszeitraum 2008-2009) in eigenen Datensatz 
moose_A <- moose_data_sex1[moose_data_sex1$id %in% c("1", "3", "5", "10"), ]
unique(moose_A)
#2. zweiten Datensatz erstellen ohne Gruppe A + ohne tote Tiere
moose_B_C<- moose_data_sex1[!moose_data_sex1$id %in% c("1", "3", "5", "10", "31", "9"), ]
#3. in moose_B_C Zeitraum begrenzen um gleichzusetzen
moose_B_C <- moose_B_C[!(moose_B_C$timestamp >= as.POSIXct("2008-12-03 00:00:00") & 
                         moose_B_C$timestamp <= as.POSIXct("2009-03-07 23:59:59")), ]
moose_B_C <- moose_B_C[moose_B_C$timestamp < as.POSIXct("2010-02-18 00:00:00"), ]
summary(moose_B_C$timestamp)
#4. wieder zusammen fÃ¼hren
moose_comb <- rbind(moose_A, moose_B_C)
dim(moose_comb)
head(moose_comb)


#5. Sex auch "beschneiden" aka 2 tote Tiere rausnehmen
sex<- sex[!sex$id %in% c("31", "9"), ]
```



## Anzeigen lassen welche Dateien drin sind

```{r}
glimpse(moose_data)
unique(moose_data$source_file)

```

## Spalten vereinfachen und umbennen und NA raus lÃ¶schen
```{r}
moose_data_sex <- moose_comb %>%
  rename(
    lat = location.lat,
    lon = location.long,
    time = timestamp
  )
moose_data_sex <- moose_data_sex %>%
  filter(!is.na(lat))
moose_data_sex <- moose_data_sex %>%
  filter(!is.na(lon))
```

```{r}
## Aufnahmezeitraum anschauen
moose_data_sex$yearday <- yday(moose_data_sex$time)
moose_data_sex$month   <- month(moose_data_sex$time)
moose_data_sex$hour    <- hour(moose_data_sex$time)
moose_data_sex$kweek   <- week(moose_data_sex$time)
moose_data_sex$date    <- date(moose_data_sex$time)
ggplot(moose_data_sex, aes(date)) +
  geom_bar() +
  theme_bw()
ggsave("Output/moose_timestamp_histogram.png", width = 10, height = 6, dpi = 300)

```

## Erste Bewegung visualisieren 

```{r}
library(ggplot2)

ggplot(moose_data_sex %>% filter(id == 1), aes(x = lon, y = lat)) +
  geom_path(color = "darkgreen") +
  labs(title = "Bewegungspfad von Elch 1", x = "Longitude", y = "Latitude") +
  theme_minimal()


ggplot(moose_data_sex, aes(x = lon, y = lat, color = factor(id))) +
  geom_path(alpha = 0.6) +
  labs(title = "Bewegungspfade aller Elche", color = "Elch-ID") +
  theme_minimal()

```


```{r}
# Daten in sf-Objekt umwandeln (WGS84-Koordinatensystem)
moose_sf <- st_as_sf(moose_data_sex, coords = c("lon", "lat"), crs = 4326)
moose_proj <- st_transform(moose_sf, crs = 3979)

bbox <- st_bbox(moose_proj)

# In ein Rechteck umwandeln
bbox_poly <- st_as_sfc(bbox)

# Jetzt 50.000 Meter (50 km) puffern
bbox_puffer <- st_buffer(bbox_poly, dist = 50000)
bbox_puffer_wgs <- st_transform(bbox_puffer, crs = 4326)
bbox_sf_proj <- st_transform(bbox_puffer, crs = 3979)

ggplot() +
  geom_sf(data = bbox_sf_proj, fill = NA, color = "red") +
  geom_sf(data = moose_proj, color = "blue", size = 0.5) +
  theme_minimal()
```

```{r}
#1. Dataframe mit Koordinaten erstellen
moose_coords <- as.data.frame(st_coordinates(moose_proj))
str(moose_coords)
moose_proj$X <- moose_coords$X
moose_proj$Y <- moose_coords$Y
#remove the spatial (geometry) column-> Converts the sf object into a regular data frame
moose_ng<- st_drop_geometry(moose_proj)
str(moose_ng)

#2. amt Objekt erstellen FÃœR EINZELNES TIER
moose1 <- moose_ng[moose_ng$id == "1", ] 
moose1_amt<- make_track(tbl= moose1, #make_track converts non-spatial data into a movement track object
                         .x= X,
                         .y= Y,
                         .t= time,
                         id= id, 
                         crs= 3979)
#3. KDE berechnen FÃœR EINZELNES TIER
kde_moose1_95 <- amt::hr_kde(x = moose1_amt, levels = c(0.95))
plot(kde_moose1_95)
hr_area(kde_moose1_95) #82887271

#4. AMT Objekt erstellen fÃ¼r GESAMT KDE BERECHNUNG
moose_ng <- moose_ng %>%
  filter(!is.na(time))
moose_amt<- make_track(tbl= moose_ng, 
                         .x= X,
                         .y= Y,
                         .t= time,
                         id= id, 
                         crs= 3979)
kde_moose_95 <- amt::hr_kde(x = moose_amt, levels = c(0.95))
plot(kde_moose_95)


#KDE fÃ¼r jedes Tier einzeln aus "gemeinsamen" amt objekt
#in tibbel umwandeln 
moose_amt_tbl <- as_tibble(moose_amt)
#gesamtergebnisse nach individuen filteren
kde_results <- moose_amt_tbl %>%
  group_by(id) %>%
  nest() %>%
  mutate(kde = map(data, ~ hr_kde(make_track(.x, .x = x_, .y = y_, .t = t_), levels = c(0.95))))  # Convert back to track
print(kde_results)
walk(kde_results$kde, plot)

#fÃ¼r jedes Tier ausgeben lassen
kde_results <- kde_results %>%
  mutate(area = map(kde, ~ hr_area(.x)$area)) 
print(kde_results)
walk(kde_results$area, print)

#12 kontrolle
kde_moose12 <- kde_results[kde_results$id == "12", ]
kde_moose12 <- kde_results %>% filter(id == "12")
kde_moose12_kde <- kde_moose12$kde[[1]]
kde_area_moose12 <- hr_area(kde_moose12_kde)
```

```{r}
#Neuen Datensatz erstellen mit FlÃ¤chenangaben und Geschlecht fÃ¼r Visualisierung ect.
#Sex datensatz als basis- alle Spalten mit nur NA entfernen
moose_data_sex_area<- sex %>%
  select(where(~ !all(is.na(.))))
#Area spalte aus kde_results anhÃ¤ngen
moose_data_sex_area <- moose_data_sex_area %>%
  left_join(kde_results %>% select(id, area), by = "id")
#Bearbeitug Datensatz
moose_data_sex_area$area<- as.numeric(unlist(moose_data_sex_area$area))
#Area Angaben in km^2 umrechnen
moose_data_sex_area$area<- moose_data_sex_area$area/1000000

boxplot(area ~ animal.sex, data = moose_data_sex_area, 
        ylim = c(0, 2000),
        main = "Home Range Area by Sex",
        xlab = "Sex",
        ylab = "Area (mÂ²)",
        col= c("lightblue", "pink"))

#Signifikanztest auf Unterschiede zwischen den Geschlechtern
hist(moose_data_sex_area$area)
wilcox.test(as.numeric(moose_data_sex_area$area)~moose_data_sex_area$animal.sex)

```


```{r}
#Plotten der KDEs

kde_results_sex <- kde_results %>%
  left_join(sex %>%
              select(id, animal.sex), by = "id")

# Vorher sicherstellen, dass moose_proj eine gÃ¼ltige CRS hat                    ##nicht nÃ¶tig?!
#if (is.na(st_crs(moose_proj))) {
#  st_crs(moose_proj) <- 3979  # Falls CRS nicht definiert ist
#}

# KDE in sf umwandeln
kde_results_sex <- kde_results_sex %>%
  mutate(kde_results = map(kde, ~ hr_isopleths(.x)))

kde_results_sex <- kde_results_sex %>%
  mutate(kde_results = map(kde_results, ~ st_set_crs(.x, 3979)))

# 1. Berechne Bounding Box (BBox) fÃ¼r jeden KDE
kde_results_sex <- kde_results_sex %>%
  mutate(bbox = map(kde_results, st_bbox)) %>%
  mutate(x_range = map_dbl(bbox, ~ .x["xmax"] - .x["xmin"]),
         y_range = map_dbl(bbox, ~ .x["ymax"] - .x["ymin"]))

# 2. Bestimme die maximalen Spannweiten
max_x_range <- max(kde_results_sex$x_range)
max_y_range <- max(kde_results_sex$y_range)

# KDEs mit angepasster Skalierung und Farbgebung plotten
kde_plots <- kde_results_sex %>%
  mutate(plot = pmap(list(kde_results, bbox, id, animal.sex), function(kde, bbox, id, sex) {
    # Mittelpunkt berechnen
    x_center <- (bbox["xmax"] + bbox["xmin"]) / 2
    y_center <- (bbox["ymax"] + bbox["ymin"]) / 2
    
    # KDE einfÃ¤rben nach Geschlecht
    ggplot() +
      geom_sf(data = kde, aes(fill = sex), alpha = 1) +  # KDE nach Geschlecht fÃ¤rben
      scale_fill_manual(values = c("f" = "lightblue", "m" = "pink")) +  # Farben fÃ¼r f und m
      ggtitle(paste("ID", id)) +
      xlim(x_center - max_x_range / 2, x_center + max_x_range / 2) +
      ylim(y_center - max_y_range / 2, y_center + max_y_range / 2) +
      theme_minimal() +
      theme(axis.text = element_blank(),
            axis.ticks = element_blank(),
            axis.title = element_blank(),
            legend.position = "none")  # Verhindert die Legende in jedem einzelnen Plot
  }))

# 4. Plots in Rasteransicht darstellen mit einer einzigen Legende
wrap_plots(kde_plots$plot) + 
  plot_layout(ncol = 6) +
  plot_annotation(title = "KDEs of Individuals", 
                  theme = theme(plot.title = element_text(size = 16, hjust = 0.5))) +
  # Eine einzelne Legende hinzufÃ¼gen
  guide_area() +
  scale_fill_manual(values = c("f" = "lightblue", "m" = "pink"), name = "animal.sex")  # Legende nur einmal erstellen



```
```{r}
#Ãœbersichtskarte mit hintergrund
library(ggplot2)
library(sf)
library(dplyr)
library(purrr)

# Umwandlung der KDE in Isoplethen (Polygone) und Zuordnung von Geschlecht
kde_results_sex <- kde_results_sex %>%
  mutate(kde_isopleths = map(kde, ~ hr_isopleths(.x)))

# Konvertierung der Isoplethen in sf-Objekte und HinzufÃ¼gen des Geschlechts
kde_results_sf <- kde_results_sex %>%
  mutate(kde_sf = map2(kde_isopleths, animal.sex, function(kde, sex) {
    kde_sf <- st_as_sf(kde)  # Konvertiert KDE in sf-Objekt
    kde_sf$sex <- sex        # FÃ¼gt das Geschlecht als Spalte hinzu
    return(kde_sf)
  }))

# Alle sf-Objekte zusammenfÃ¼hren
kde_all_sf <- do.call(rbind, kde_results_sf$kde_sf)

# Plot der gesamten KDEs auf einer Karte mit GeschlechtsfÃ¤rbung
ggplot() +
  geom_sf(data = kde_all_sf, aes(fill = factor(sex)), color = "blue", alpha = 0.5) +  # Geschlecht fÃ¤rben
  scale_fill_manual(values = c("f" = "lightblue", "m" = "pink"), name = "Sex") +  # Farben fÃ¼r Geschlecht
  theme_minimal() +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank()) +
  ggtitle("KDE Results of All Individuals by Sex")


```


# Landcover Daten

## Kurzinfo zum Datensatz:

    NALCMS 2010 Land Cover fÃ¼r Kanada.

    Rasterdaten (GeoTIFF), 30 m AuflÃ¶sung.

    Klassifiziert in 19 Landbedeckungstypen (z.B. Nadelwald, Feuchtgebiete, stÃ¤dtisch).

    Projektion: EPSG:3979 (Lambert Conformal Conic).

## Datenimport und erste Rasteranalyse  

Der folgende Code-Chunk ist nicht auszufÃ¼hren, da der Datensatz zu groÃŸ fÃ¼r das GitHub ist. Alle weiteren Schritte werden mit dem Zuschnitt auf das Untersuchungsgebiet gemacht, der Zuschnitt wird im nÃ¤chsten Chunk eingeladen.

```{r}
#cand_Landcover_3979 <- rast("C:/Users/Florian/Downloads/landcover-2010-classification.tif")

# Ãœbersicht
#cand_Landcover_3979
#plot(cand_Landcover_3979)
#levels(cand_Landcover_3979)
#freq(cand_Landcover_3979)

# Zuschneiden auf das Untersuchungsgebiet 

#bbox_sf_proj <- st_transform(bbox_puffer, crs(cand_Landcover_3979))

#cand_Landcover_studyarea_3979 <- crop(cand_Landcover_3979, bbox_sf_proj)
freq(cand_Landcover_studyarea_3979) #vllt noch interessant (HÃ¤ufigkeit der Landnutzungsklassen)
#plot(cand_Landcover_studyarea_3979)

# Speichern der Datei fÃ¼r weitere Arbeitsschritte 
#writeRaster(cand_Landcover_studyarea_3979, "cand_Landcover_studyarea_3979.tif", filetype = "GTiff", overwrite = TRUE)
```

## Dateiimport GitHub kompatibel

Ab hier kann 
```{r}
cand_Landcover_studyarea_3979 <- terra::rast(here("data", "cand_Landcover_studyarea_3979.tif"))

# Zuordnung der Gruppen (gemÃ¤ÃŸ Metadaten des Datensatzes)
# FÃ¼r die SpÃ¤tere Darstellung im GGplot
landcover_classes <- data.frame(
  code = 1:19,
  class = c(
    "Temperate or sub-polar needleleaf forest",
    "Sub-polar taiga needleleaf forest",
    "Tropical or sub-tropical broadleaf evergreen forest",
    "Tropical or sub-tropical broadleaf deciduous forest",
    "Temperate or sub-polar broadleaf deciduous forest",
    "Mixed forest",
    "Tropical or sub-tropical shrubland",
    "Temperate or sub-polar shrubland",
    "Tropical or sub-tropical grassland",
    "Temperate or sub-polar grassland",
    "Sub-polar or polar shrubland-lichen-moss",
    "Sub-polar or polar grassland-lichen-moss",
    "Sub-polar or polar barren-lichen-moss",
    "Wetland",
    "Cropland",
    "Barren lands",
    "Urban and built-up",
    "Water",
    "Snow and ice"
  )
)


plot(cand_Landcover_studyarea_3979)
```

# DEM Kanda

## Kurzinfo zum Datensatz:

    Canadian Digital Elevation Model (CDEM) â€“ Mosaik aus HÃ¶henrasterdaten von NRCan.

    AuflÃ¶sung: Horizontal 10â€“100m, vertikale Genauigkeit 8â€“43m.

    Koordinatensystem: EPSG:4617 (geografisch), HÃ¶henbezug EPSG:5713.

    Format: GeoTIFF, verfÃ¼gbar als vordefiniertes oder benutzerdefiniertes Mosaik.

## Datenimport

Das Natural Resources Canada stellt die DEM kostenlos zur VerfÃ¼gung, folgenden Video erklÃ¤rt den Daten-Download:
https://www.youtube.com/watch?v=dfHNghqHdXI&ab_channel=DonBoyes

```{r}
# Indentifizierung der Indexnummern zum Download der richtigen DEM Abschnitte
# Die Zuordnung der Indexnummern ist als shape Datei zu downloaden:
# https://open.canada.ca/data/en/dataset/7f245e4d-76c2-4caa-951a-45d1d2051333

nts_index <- st_read("data/DEM/nts_snrc_1m.shp")
nts_index_proj <- st_transform(nts_index, crs = 3979)

ggplot() +
  geom_sf(data = nts_index_proj, aes(fill = IDENTIF), color = "black", alpha = 0.4, show.legend = FALSE) +
  geom_sf_text(data = nts_index_proj, aes(label = IDENTIF), size = 3) +
  geom_sf(data = bbox_sf_proj, fill = NA, color = "red", linewidth = 1) +
  theme_minimal()

# Eine Stufe feiner zum Download benÃ¶tigt

nts_index_2 <- st_read("data/DEM/nts_snrc_250k.shp")
nts_index_proj_2 <- st_transform(nts_index_2, crs = 3979)

# Vorbereitung zum festlegen von xlim und ylim, da Indexnummern im 1. Versuch auf der Karte nicht lesbar

bbox <- st_bbox(bbox_sf_proj)
expand <- 10000  # in Metern (bei Projektionssystem in Meter)

# Optische Identifizierung der DEM Abschnitte (AnschlieÃŸend: manueller Download im FTP-Verzeichnis)

ggplot() +
  geom_sf(data = nts_index_proj, aes(fill = IDENTIF), color = "black", alpha = 0.4, show.legend = FALSE) +
  geom_sf(data = nts_index_proj_2, aes(fill = NTS_SNRC), color = "black", alpha = 0.4, show.legend = FALSE) +
  geom_sf_text(data = nts_index_proj_2, aes(label = NTS_SNRC), size = 2) +
  geom_sf(data = moose_proj, color = "red", size = 0.4, alpha = 0.6) +
   geom_sf(data = bbox_sf_proj, fill = NA, color = "red", linewidth = 1) +
  coord_sf(
    xlim = c(bbox["xmin"] - expand, bbox["xmax"] + expand),
    ylim = c(bbox["ymin"] - expand, bbox["ymax"] + expand)
  ) +
  theme_minimal()

# Dateipfade aller GeoTIFFs aus dem Verzeichnis holen

#dem_files <- list.files("data/DEM", pattern = "\\.tif$", full.names = TRUE)

# Alle DEMs einlesen und zu einem Mosaik zusammenfÃ¼gen

#dem_list <- lapply(dem_files, rast)
#dem_mosaic <- do.call(mosaic, dem_list)

#In das richtige CRS projezieren. ACHTUNG! - nicht erneut ausfÃ¼hren dauert sehr lange!:

#dem_mosaic_3979 <- project(dem_mosaic, cand_Landcover_3979)
#dem_studyarea <- crop(dem_mosaic_3979, bbox_sf_proj)
#writeRaster(dem_studyarea, "data/DEM/dem_studyarea_3979.tif",
#            filetype = "GTiff",
#            wopt = list(gdal = c("COMPRESS=LZW")),
#            overwrite = TRUE)

# Auch die komprimierte Datei ist zu groÃŸ fÃ¼r GitHUB (daher manueller download und einfÃ¼gen in die Ordnerstruktur)
dem_studyarea_3979 <- terra::rast(here("data", "DEM", "dem_studyarea_3979.tif"))

# Plot zur Kontrolle
plot(dem_studyarea_3979)


```

# Resource selection funciton

## Vorbereitung des Umweltvariablen-Stacks fÃ¼r die RSF

```{r}
# Landcover-Raster wird auf die AuflÃ¶sung des DEM resampled (nearest neighbor fÃ¼r kategoriale Daten)

cand_Landcover_aligned <- resample(cand_Landcover_studyarea_3979, dem_studyarea_3979, method = "near")

# DEM wird standardisiert (z-transformiert) - Auch nicht unbedingt nochmal ausfÃ¼hren.
# dem_mosaic_scaled <- scale(dem_studyarea_3979)
# Skalierter DEM wird komprimiert als GeoTIFF gespeichert und erneut eingelesen
# writeRaster(dem_mosaic_scaled, "data/DEM/dem_studyarea_scaled.tif",
#          filetype = "GTiff",
#          wopt = list(gdal = c("COMPRESS=LZW")),
#          overwrite = TRUE)

# Datei zu groÃŸ fÃ¼r GitHub, kombrimierte Datei manuell downloaden und in Ordnerstruktur einfÃ¼gen.

dem_studyarea_scaled <- terra::rast(here("data", "DEM", "dem_studyarea_scaled.tif"))

# Stack aus beiden Rastern

rsf_stack <- c(cand_Landcover_aligned, dem_studyarea_scaled)
names(rsf_stack) <- c("landcover", "elevation")

# Kontrolle

plot(rsf_stack)

```

## Kontrolle auf Korrelation 
(unsicher wie nÃ¶tig dieser Test hier ist)

```{r}
library(corrplot)

# Korrelation berechnen
M <- terra::layerCor(rsf_stack, fun = "pearson")

# Plot der Korrelationsmatrix
corrplot(M$correlation, type = "upper", tl.col = "black", tl.srt = 45)
```

## Vorbereitung zur Erstellung der Random-Points

1. Reduzierung des Datensatz: Die nÃ¤chstgelegende Aufnahme zu 13 Uhr!
2. Vorbereitung der KDE (Home Ranges)
3. HinzufÃ¼gen der Random-Points
```{r}
#Kontrolle wie viele Datenpunkte pro ID enthalten sind
table(moose_amt$id)

#Funktion fÃ¼r Punkt 1 (Individum bezogen)
get_daily_near13 <- function(df) {
  df %>%
    mutate(date = as.Date(t_),
           diff_13 = abs(lubridate::hour(t_) + lubridate::minute(t_) / 60 - 13)) %>%
    group_by(id, date) %>%
    slice_min(order_by = diff_13, with_ties = FALSE) %>%
    ungroup()
}

# AusfÃ¼hrung der Funktion
moose_13 <- get_daily_near13(moose_amt)

# Kontrolle, wie viele Datenpunkte pro Tier geblieben sind
table(moose_13$id)

# Vorbereitung der KDE (Polygone fÃ¼r Punkterzeugung)
kde_results <- kde_results %>%
  mutate(poly_95 = map(kde, ~ hr_isopleths(.x)))

# Kontrolle ob fÃ¼r jedes Tier ein Polygon vorhanden ist
kde_results %>%
  mutate(valid_poly = map_lgl(poly_95, ~ !is.null(.x) && nrow(.x) > 0)) %>%
  count(valid_poly)

# Erstellung der Punkte
kde_randompoints <- kde_results %>%
  filter(id %in% moose_13$id) %>%
  transmute(id, random_points = map2(poly_95, id, ~ st_sample(.x, 
    size = sum(moose_13$id == .y) * 20, type = "random")))

# Kontrolle wie viele Punkte es sind
kde_randompoints %>%
  mutate(n_random = map_int(random_points, length)) %>%
  select(id, n_random)

```
## Umweltvariablen fÃ¼r die Punkte extrahieren

###Ablauftest fÃ¼r ein Individuum zur Vorbereitung einer Funktion
```{r}

# 1. Geometrie holen und in sf-Objekt umwandeln
rp_sf_1 <- st_as_sf(kde_randompoints$random_points[[1]])

# 2. Koordinaten extrahieren
coords <- st_coordinates(rp_sf_1)

# 3. Track-Objekt erstellen
rp_track_1 <- make_track(
  tbl = tibble(x = coords[,1], y = coords[,2], id = "1"),
  .x = x, .y = y, id = id, crs = 3979
)

# 4. Extraktion
env_rp_1 <- extract_covariates(rp_track_1, rsf_stack)
```


### Funktion zur Extraktion der Habitatvariablen (TRUE und Random Points)
```{r}
env_all_list <- list()

for (i in seq_len(nrow(kde_randompoints))) {
  id <- kde_randompoints$id[i]
  geom <- kde_randompoints$random_points[[i]]
  
  # Random Points zu Koordinaten
  coords <- st_coordinates(geom)
  rp_tbl <- tibble(x = coords[,1], y = coords[,2], id = id)
  rp_track <- make_track(rp_tbl, .x = x, .y = y, id = id, crs = 3979)
  env_rp <- extract_covariates(rp_track, rsf_stack)
  env_rp$case_ <- FALSE
  
  # True Points
  moose_df <- moose_13 %>% filter(id == !!id)
  moose_track <- make_track(moose_df, .x = x_, .y = y_, .t = t_, id = id, crs = 3979)
  env_true <- extract_covariates(moose_track, rsf_stack)
  env_true$case_ <- TRUE
  
  # Kombinieren
  env_all_list[[as.character(id)]] <- bind_rows(env_true, env_rp)
}
```

# Resource selection function

GLMM (binomial, logit-Link) mit:

    festen Effekten: elevation + landcover

    Zufallsinterzept fÃ¼r id â†’ erlaubt individuelle Variation je Elch
    
```{r}
# Vorbereitung der Daten fÃ¼r das GLMM
rsf_df <- bind_rows(env_all_list)
rsf_df$case_ <- as.integer(rsf_df$case_)  # TRUE/FALSE â†’ 1/0

# Anwednung GLMM
library(lme4)
model_glmm <- glmer(case_ ~ elevation + as.factor(landcover) + (1 | id),
                    data = rsf_df,
                    family = binomial)

# Ergebniszusammenfassung
summary(model_glmm)

# Speichern des fertigen GLMM-Objekts
saveRDS(model_glmm, file = here::here("output", "model_glmm.rds"))

# Einlesen bei spÃ¤terer Nutzung
#model_glmm <- readRDS("results/model_glmm.rds")
```

# Visualisierung der Ergebnisse
```{r}
# 1. Effekt-Koeffizienten extrahieren
coefs <- summary(model_glmm)$coefficients %>%
  as.data.frame() %>%
  rownames_to_column("term") %>%
  filter(term == "elevation" | grepl("as.factor\\(landcover\\)", term)) %>%
  mutate(
    landcover_code = as.numeric(gsub("as.factor\\(landcover\\)", "", term)),
    class = ifelse(term == "elevation", "Elevation", landcover_classes$class[match(landcover_code, landcover_classes$code)]),
    lower = Estimate - 1.96 * `Std. Error`,
    upper = Estimate + 1.96 * `Std. Error`
  ) %>%
  filter(abs(Estimate) < 10)  # entfernt Extremwerte


# 2. Plot
ggplot(coefs, aes(x = reorder(class, Estimate), y = Estimate)) +
  geom_point() +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  coord_flip() +
  labs(x = "Variable", y = "Effekt (log-Odds)",
       title = "RSF-Modell: Effekte von HÃ¶he & Landnutzung") +
  theme_minimal()

ggsave("RSF Model Values.png", width = 8, height = 6, dpi = 300)
```

```{r}
ranef_df <- ranef(model_glmm)$id %>%
  tibble::rownames_to_column("id") %>%
  rename(intercept = `(Intercept)`)

ggplot(ranef_df, aes(x = reorder(id, intercept), y = intercept)) +
  geom_col(fill = "steelblue") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Individuum (ID)", y = "ZufÃ¤lliger Interzept",
       title = "Individuelle Abweichung im RSF (Random Intercepts)") +
  theme_minimal()

```


