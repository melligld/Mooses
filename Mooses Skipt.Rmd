---
title: "Mooses Movement"
output: html_document
date: "2025-03-23"
---

# Pakete laden
```{r}
library(here)
library(readr)
library(skimr)
library(dplyr)
library(tidyverse)
library(sf)
library(amt)
```

# Pfad automatisch setzen 

```{r}
here::here()
```

# Git Installieren:

Git Programm herunterladen: 
https://git-scm.com/downloads

Notiz: Nach der Installation R neustarten.

Git Projekt beitreten:
Folgendem Git-Ordner beitreten und auf der Website bei GitHub anmelden (Uni-Mail)
Benutzernamen erstellen und an Melanie schicken, damit ihr vollen Zugriff bekommt.

https://github.com/melligld/Mooses

Danach in R "File > New Project > Version Control > Git"

Dort dann den obigen Link einfügen, damit ladet ihr den Git-Ordner herunter. 

================================
📦 Git-Workflow für das R-Projekt
================================
🛠 1. Git einrichten (nur einmal notwendig)
Gebt euren Namen und eure E-Mail-Adresse an, damit eure Commits zugeordnet werden können:
Im Terminal:
git config --global user.name "Username"
git config --global user.email "MaxMustermann@campus.tu-berlin.de"

=====================================
🚀 Täglicher Workflow mit Git in RStudio
=====================================

1️⃣ Vor dem Arbeiten: Änderungen von anderen holen
(Git-Tab in RStudio → Klick auf „Pull“)
oder im Terminal: git pull

2️⃣ Dann wie gewohnt arbeiten:
- Skripte oder Dateien ändern
- Ergebnisse speichern

3️⃣ Änderungen zum Commit auswählen:
(Git-Tab → Häkchen bei den geänderten Dateien setzen)

4️⃣ Commit erstellen:
- Im Git-Tab Nachricht schreiben (z.B. „Analyse ergänzt“)
- Dann auf „Commit“ klicken

5️⃣ Änderungen hochladen:
- Git-Tab → „Push“ klicken
oder im Terminal: git push

💡 Tipp: Lieber häufiger kleine Commits machen statt einen großen am Ende!

=====================================
✅ Zusammengefasst:
=====================================
git pull     → aktuelle Änderungen holen
git add .    → alle Änderungen für Commit vormerken (meist über Git-Tab gemacht)
git commit -m "Kurze Nachricht" → Änderung speichern
git push     → Änderungen ins GitHub-Projekt hochladen

=====================================
❗️Wichtig:
=====================================
➤ Immer vor dem Arbeiten zuerst ein `pull` machen.
➤ Nur pushen, wenn du committed hast und keine Konflikte offen sind.



# Alle CSVs einlesen und zusammenfügen 

```{r}
# Ordnerpfad zu den CSV-Dateien
data_path <- here("data")
sex_data_path <- here("data", "sex_data", "Peters_Hebblewhite_Alberta-BC_Moose-reference-data.csv")
# Liste aller CSV-Dateien im data-Ordner
csv_files <- list.files(path = data_path, pattern = "\\.csv$", full.names = TRUE)

# Alle CSVs einlesen und zu einem Dataframe zusammenfügen
moose_data <- purrr::map_dfr(csv_files, read_csv, .id = "source_file", show_col_types= FALSE)
colnames(moose_data)[colnames(moose_data) == "tag.local.identifier"] <- "id"

#Geschlechter Zuordnung
sex<- read.csv(sex_data_path)
colnames(sex)[colnames(sex) == "animal.id"] <- "id"

#Moose Datensatz mit Geschlechterzuordnung
moose_data_sex1 <- moose_data %>%
  left_join(sex[, c("id", "animal.sex")], by = "id")

```
##Datensatz "beschneiden"
```{r}
#1. Gruppe A (Datenerhebungszeitraum 2008-2009) in eigenen Datensatz 
moose_A <- moose_data_sex1[moose_data_sex1$id %in% c("1", "3", "5", "10"), ]
unique(moose_A)
#2. zweiten Datensatz erstellen ohne Gruppe A + ohne tote Tiere
moose_B_C<- moose_data_sex1[!moose_data_sex1$id %in% c("1", "3", "5", "10", "31", "9"), ]
#3. in moose_B_C Zeitraum begrenzen um gleichzusetzen
moose_B_C <- moose_B_C[!(moose_B_C$timestamp >= as.POSIXct("2008-12-03 00:00:00") & 
                         moose_B_C$timestamp <= as.POSIXct("2009-03-07 23:59:59")), ]
moose_B_C <- moose_B_C[moose_B_C$timestamp < as.POSIXct("2010-02-18 00:00:00"), ]
summary(moose_B_C$timestamp)
#4. wieder zusammen führen
moose_comb <- rbind(moose_A, moose_B_C)
dim(moose_comb)
head(moose_comb)


#5. Sex auch "beschneiden" aka 2 tote Tiere rausnehmen
sex<- sex[!sex$id %in% c("31", "9"), ]
```



## Anzeigen lassen welche Dateien drin sind

```{r}
glimpse(moose_data)
unique(moose_data$source_file)

```

## Spalten vereinfachen und umbennen und NA raus löschen
```{r}
moose_data_sex <- moose_comb %>%
  rename(
    lat = location.lat,
    lon = location.long,
    time = timestamp
  )
moose_data_sex <- moose_data_sex %>%
  filter(!is.na(lat))
moose_data_sex <- moose_data_sex %>%
  filter(!is.na(lon))
```

```{r}
## Aufnahmezeitraum anschauen
moose_data_sex$yearday <- yday(moose_data_sex$time)
moose_data_sex$month   <- month(moose_data_sex$time)
moose_data_sex$hour    <- hour(moose_data_sex$time)
moose_data_sex$kweek   <- week(moose_data_sex$time)
moose_data_sex$date    <- date(moose_data_sex$time)
ggplot(moose_data_sex, aes(date)) +
  geom_bar() +
  theme_bw()
ggsave("Output/moose_timestamp_histogram.png", width = 10, height = 6, dpi = 300)

```

## Erste Bewegung visualisieren 

```{r}
library(ggplot2)

ggplot(moose_data_sex %>% filter(id == 1), aes(x = lon, y = lat)) +
  geom_path(color = "darkgreen") +
  labs(title = "Bewegungspfad von Elch 1", x = "Longitude", y = "Latitude") +
  theme_minimal()


ggplot(moose_data_sex, aes(x = lon, y = lat, color = factor(id))) +
  geom_path(alpha = 0.6) +
  labs(title = "Bewegungspfade aller Elche", color = "Elch-ID") +
  theme_minimal()

```


```{r}
# Daten in sf-Objekt umwandeln (WGS84-Koordinatensystem)
moose_sf <- st_as_sf(moose_data_sex, coords = c("lon", "lat"), crs = 4326)
moose_proj <- st_transform(moose_sf, crs = 3979)

bbox <- st_bbox(moose_proj)

# In ein Rechteck umwandeln
bbox_poly <- st_as_sfc(bbox)

# Jetzt 50.000 Meter (50 km) puffern
bbox_puffer <- st_buffer(bbox_poly, dist = 50000)
bbox_puffer_wgs <- st_transform(bbox_puffer, crs = 4326)

ggplot() +
  geom_sf(data = bbox_sf_proj, fill = NA, color = "red") +
  geom_sf(data = moose_proj, color = "blue", size = 0.5) +
  theme_minimal()
```
git config --global user.email "krieger.1@campus.tu-berlinde"
  git config --global user.name "NicoTU-byte"

```{r}
#1. Dataframe mit Koordinaten erstellen
moose_coords <- as.data.frame(st_coordinates(moose_proj))
str(moose_coords)
moose_proj$X <- moose_coords$X
moose_proj$Y <- moose_coords$Y
#remove the spatial (geometry) column-> Converts the sf object into a regular data frame
moose_ng<- st_drop_geometry(moose_proj)
str(moose_ng)

#2. amt Objekt erstellen FÜR EINZELNES TIER
moose1 <- moose_ng[moose_ng$id == "1", ] 
moose1_amt<- make_track(tbl= moose1, #make_track converts non-spatial data into a movement track object
                         .x= X,
                         .y= Y,
                         .t= time,
                         id= id, 
                         crs= 3979)
#3. KDE berechnen FÜR EINZELNES TIER
kde_moose1_95 <- amt::hr_kde(x = moose1_amt, levels = c(0.95))
plot(kde_moose1_95)
hr_area(kde_moose1_95) #82887271

#4. AMT Objekt erstellen für GESAMT KDE BERECHNUNG
moose_ng <- moose_ng %>%
  filter(!is.na(time))
moose_amt<- make_track(tbl= moose_ng, 
                         .x= X,
                         .y= Y,
                         .t= time,
                         id= id, 
                         crs= 3979)
kde_moose_95 <- amt::hr_kde(x = moose_amt, levels = c(0.95))
plot(kde_moose_95)

#KDE für jedes Tier einzeln aus "gemeinsamen" amt objekt
#in tibbel umwandeln 
moose_amt_tbl <- as_tibble(moose_amt)
#gesamtergebnisse nach individuen filteren
kde_results <- moose_amt_tbl %>%
  group_by(id) %>%
  nest() %>%
  mutate(kde = map(data, ~ hr_kde(make_track(.x, .x = x_, .y = y_, .t = t_), levels = c(0.95))))  # Convert back to track
print(kde_results)
walk(kde_results$kde, plot)

#für jedes Tier ausgeben lassen
kde_results <- kde_results %>%
  mutate(area = map(kde, ~ hr_area(.x)$area)) 
print(kde_results)
walk(kde_results$area, print)

#12 kontrolle
kde_moose12 <- kde_results[kde_results$id == "12", ]
kde_moose12 <- kde_results %>% filter(id == "12")
kde_moose12_kde <- kde_moose12$kde[[1]]
kde_area_moose12 <- hr_area(kde_moose12_kde)
```

```{r}
#Neuen Datensatz erstellen mit Flächenangaben und Geschlecht für Visualisierung ect.
#Sex datensatz als basis- alle Spalten mit nur NA entfernen
moose_data_sex_area<- sex %>%
  select(where(~ !all(is.na(.))))
#Area spalte aus kde_results anhängen
moose_data_sex_area <- moose_data_sex_area %>%
  left_join(kde_results %>% select(id, area), by = "id")
#Bearbeitug Datensatz
moose_data_sex_area$area<- as.numeric(unlist(moose_data_sex_area$area))
#Area Angaben in km^2 umrechnen
moose_data_sex_area$area<- moose_data_sex_area$area/1000000

boxplot(area ~ animal.sex, data = moose_data_sex_area, 
        ylim = c(0, 2000),
        main = "Home Range Area by Sex",
        xlab = "Sex",
        ylab = "Area (m²)",
        col= c("lightblue", "pink"))

#Signifikanztest auf Unterschiede zwischen den Geschlechtern
hist(moose_data_sex_area$area)
wilcox.test(as.numeric(moose_data_sex_area$area)~moose_data_sex_area$animal.sex)

```
# Landcover Daten

## Kurzinfo zum Datensatz:

    NALCMS 2010 Land Cover (30 m) für Kanada.

    Rasterdaten (GeoTIFF), 30 m Auflösung.

    Klassifiziert in 19 Landbedeckungstypen (z.B. Nadelwald, Feuchtgebiete, städtisch).

    Projektion: EPSG:3979 (Lambert Conformal Conic).
## Datenimport und erste Rasteranalyse  

```{r}
library(terra)

cand_Landcover_3979 <- rast("C:/Users/Florian/Downloads/landcover-2010-classification.tif")

# Übersicht
cand_Landcover_3979
plot(cand_Landcover_3979)
levels(cand_Landcover_3979)
#freq(cand_Landcover_3979)

# Zuordnung der Gruppen (gemäß Metadaten des Datensatzes)
landcover_classes <- data.frame(
  code = 1:19,
  class = c(
    "Temperate or sub-polar needleleaf forest",
    "Sub-polar taiga needleleaf forest",
    "Tropical or sub-tropical broadleaf evergreen forest",
    "Tropical or sub-tropical broadleaf deciduous forest",
    "Temperate or sub-polar broadleaf deciduous forest",
    "Mixed forest",
    "Tropical or sub-tropical shrubland",
    "Temperate or sub-polar shrubland",
    "Tropical or sub-tropical grassland",
    "Temperate or sub-polar grassland",
    "Sub-polar or polar shrubland-lichen-moss",
    "Sub-polar or polar grassland-lichen-moss",
    "Sub-polar or polar barren-lichen-moss",
    "Wetland",
    "Cropland",
    "Barren lands",
    "Urban and built-up",
    "Water",
    "Snow and ice"
  )
)

# Zuschneiden auf das Untersuchungsgebiet: 

bbox_sf_proj <- st_transform(bbox_puffer, crs(cand_Landcover_3979))

cand_Landcover_studyarea_3979 <- crop(cand_Landcover_3979, bbox_sf_proj)

plot(cand_Landcover_studyarea_3979)
#freq(cand_Landcover_studyarea_3979) #vllt noch interessant (Häufigkeit der Landnutzungsklassen)

writeRaster(cand_Landcover_studyarea_3979, "cand_Landcover_studyarea_3979.tif", filetype = "GTiff", overwrite = TRUE)
```

# DEM Kanda

Canadian Digital Elevation Model (CDEM) – Mosaik aus Höhenrasterdaten von NRCan.

Auflösung: Horizontal 10–100m, vertikale Genauigkeit 8–43m.

Koordinatensystem: EPSG:4617 (geografisch), Höhenbezug EPSG:5713.

Format: GeoTIFF, verfügbar als vordefiniertes oder benutzerdefiniertes Mosaik.

## Datenimport
```{r}
library(sf)
# Indentifizierung der Indexnummern zum Download der richtigen DEM Abschnitte
nts_index <- st_read("data/DEM/nts_snrc_1m.shp")
nts_index_proj <- st_transform(nts_index, crs(cand_Landcover_3979))

ggplot() +
  geom_sf(data = nts_index_proj, aes(fill = IDENTIF), color = "black", alpha = 0.4, show.legend = FALSE) +
  geom_sf_text(data = nts_index_proj, aes(label = IDENTIF), size = 3) +
  geom_sf(data = bbox_sf_proj, fill = NA, color = "red", linewidth = 1) +
  theme_minimal()

# Eine Stufe feiner zum Download benötigt
nts_index_2 <- st_read("data/DEM/nts_snrc_250k.shp")
nts_index_proj_2 <- st_transform(nts_index_2, crs(cand_Landcover_3979))

# Vorbereitung zum festlegen von xlim und ylim, da gesamte Karte nicht lesbar
bbox <- st_bbox(bbox_sf_proj)
expand <- 10000  # in Metern (bei Projektionssystem in Meter)

ggplot() +
  geom_sf(data = nts_index_proj, aes(fill = IDENTIF), color = "black", alpha = 0.4, show.legend = FALSE) +
  geom_sf(data = nts_index_proj_2, aes(fill = NTS_SNRC), color = "black", alpha = 0.4, show.legend = FALSE) +
  geom_sf_text(data = nts_index_proj_2, aes(label = NTS_SNRC), size = 2) +
  geom_sf(data = moose_proj, color = "red", size = 0.4, alpha = 0.6) +
   geom_sf(data = bbox_sf_proj, fill = NA, color = "red", linewidth = 1) +
  coord_sf(
    xlim = c(bbox["xmin"] - expand, bbox["xmax"] + expand),
    ylim = c(bbox["ymin"] - expand, bbox["ymax"] + expand)
  ) +
  theme_minimal()

# Optische Identifizierung der DEM Abschnitte (manueller Download im FTP-Verzeichnis)

# Dateipfade aller GeoTIFFs aus dem Verzeichnis holen
dem_files <- list.files("data/DEM", pattern = "\\.tif$", full.names = TRUE)

# Alle DEMs einlesen und zu einem Mosaik zusammenfügen
dem_list <- lapply(dem_files, rast)
dem_mosaic <- do.call(mosaic, dem_list)

# Plot zur Kontrolle
plot(dem_mosaic)

dem_mosaic_3979 <- project(dem_mosaic, cand_Landcover_3979)

dem_studyarea <- crop(dem_mosaic_3979, bbox_sf_proj)

writeRaster(dem_studyarea, "data/DEM/dem_studyarea_3979.tif",
            filetype = "GTiff",
            wopt = list(gdal = c("COMPRESS=LZW")),
            overwrite = TRUE)

```

# Resource selection funciton

## Datensatz auf einen Ort pro Tag begrenzen. 
Auswahl um die Mittagsaufnahme 13 Uhr (Abdeckung der Tagesaktivität im Umkreis wahrscheinlich)
```{r}
library(dplyr)
library(lubridate)
#Filter nach Aufnahmezeitpunkt um 13 Uhr
moose_13 <- moose_amt %>%
  filter(hour(t_) == 12 & minute(t_) >= 30 | hour(t_) == 13 & minute(t_) <= 30)
```

```{r}
# Prüfen ob gleiche Auflösung, Extent & CRS – ggf. anpassen
cand_Landcover_aligned <- resample(cand_Landcover_studyarea_3979, dem_mosaic_3979, method = "near")
dem_mosaic_scaled <- scale(dem_mosaic_3979)

writeRaster(dem_mosaic_scaled, "data/DEM/dem_mosaic_scaled.tif",
            filetype = "GTiff",
            wopt = list(gdal = c("COMPRESS=LZW")),
            overwrite = TRUE)

# Stack aus beiden Rastern
rsf_stack <- c(cand_Landcover_aligned, dem_mosaic_scaled)
names(rsf_stack) <- c("landcover", "elevation")

# Kontrolle
plot(rsf_stack)

```
```{r}
library(corrplot)

# Korrelation berechnen
M <- terra::layerCor(rsf_stack, fun = "pearson")

# Plot der Korrelationsmatrix
corrplot(M$correlation, type = "upper", tl.col = "black", tl.srt = 45)

```


```{r}
# IDs bestimmen
moose_ids <- unique(moose_ng$id)

# Liste zum Speichern
kde_list_new <- list()

# Saubere KDE-Berechnung mit Fehlerbehandlung
for (id in moose_ids) {
  cat("Berechne KDE für ID:", id, "\n")
  
  df <- moose_ng %>% filter(id == !!id)
  
  if (nrow(df) < 5) {
    message("Zu wenige Punkte für ID: ", id)
    next
  }

  df <- df %>% filter(!is.na(time))  # Neue Zeile!
  
  if (nrow(df) < 5) {
    message("Zu wenige gültige Zeitpunkte für ID: ", id)
    next
  }
  
  track <- make_track(df, .x = X, .y = Y, .t = time, id = id, crs = 3979)
  
  kde <- tryCatch({
    hr_kde(track, levels = 0.95)
  }, error = function(e) {
    message("Fehler bei ID ", id, ": ", e$message)
    return(NULL)
  })
  
  if (!is.null(kde)) {
    terra::crs(kde$ud) <- "EPSG:3979"
    terra::crs(kde$trast) <- "EPSG:3979"
  }
  
  kde_list_new[[as.character(id)]] <- kde
}


class(kde_list_new[["12"]])
plot(kde_list_new[["25"]])
hr_area(kde_list_new[["12"]])


```

```{r}
moose_coords <- as.data.frame(st_coordinates(moose_proj))
moose_proj$X <- moose_coords$X
moose_proj$Y <- moose_coords$Y
moose_ng <- st_drop_geometry(moose_proj) 

# amt-kompatibles Track-Objekt
moose12 <- moose_ng %>%
  filter(id == "12") %>%
  filter(lubridate::hour(time) == 12 & lubridate::minute(time) >= 30 |
         lubridate::hour(time) == 13 & lubridate::minute(time) <= 30)

# Jetzt klappt's:
my_moose_12 <- make_track(moose12, .x = X, .y = Y, .t = time, id = id, crs = 3979)

# KDE aus der neuen Liste
kde_12 <- kde_list_new[["12"]]
class(kde_12) <- c("hr_kde", "hr_prob", "hr", "list")
# Random Points innerhalb der KDE
rp_moose_12 <- random_points(my_moose_12, n = nrow(my_moose_12), hr = kde_12)

# Zusammenführen zu RSF-Daten
rsf_12 <- bind_rows(
  mutate(my_moose_12, case_ = TRUE),
  mutate(rp_moose_12, case_ = FALSE)
)

```



